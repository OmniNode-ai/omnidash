/**
 * Data Source Health Routes (OMN-2307)
 *
 * Exposes GET /api/health/data-sources to report the live/mock status of every
 * dashboard data source. The endpoint probes each backing API (or projection)
 * to determine whether real data is available, then returns a structured
 * summary suitable for a pre-demo readiness check.
 *
 * Response shape:
 * {
 *   dataSources: {
 *     [key: string]: {
 *       status: "live" | "mock" | "error";
 *       reason?: string;   // present when status != "live"
 *       lastEvent?: string; // ISO timestamp, present when status == "live"
 *     }
 *   },
 *   summary: { live: number; mock: number; error: number },
 *   checkedAt: string; // ISO timestamp
 * }
 */

import { Router } from 'express';
import { projectionService, enforcementProjection } from './projection-bootstrap';
import type {
  ExtractionMetricsProjection,
  ExtractionMetricsPayload,
} from './projections/extraction-metrics-projection';
import type {
  EffectivenessMetricsProjection,
  EffectivenessMetricsPayload,
} from './projections/effectiveness-metrics-projection';
import type {
  CostMetricsProjection,
  CostMetricsPayload,
} from './projections/cost-metrics-projection';
import type { BaselinesProjection, BaselinesPayload } from './projections/baselines-projection';
import type { IntentProjectionPayload, NodeRegistryPayload } from '@shared/projection-types';
import type { EventBusPayload } from '@shared/event-bus-payload';
import type {
  ValidationProjection,
  ValidationProjectionPayload,
} from './projections/validation-projection';
import type {
  PatternsProjection,
  PatternsProjectionPayload,
} from './projections/patterns-projection';
import { tryGetIntelligenceDb } from './storage';
import { patternLearningArtifacts } from '@shared/intelligence-schema';
import { count } from 'drizzle-orm';
import { getEventBusDataSource } from './event-bus-data-source';
import {
  TOPIC_OMNICLAUDE_AGENT_ACTIONS,
  TOPIC_OMNICLAUDE_ROUTING_DECISIONS,
  TOPIC_OMNICLAUDE_AGENT_TRANSFORMATION,
  LEGACY_AGENT_ACTIONS,
  LEGACY_AGENT_ROUTING_DECISIONS,
  LEGACY_AGENT_TRANSFORMATION_EVENTS,
} from '../shared/topics';

// ============================================================================
// Types
// ============================================================================

export type DataSourceStatus = 'live' | 'mock' | 'error';

export interface DataSourceInfo {
  status: DataSourceStatus;
  /** Present when status is 'mock' or 'error', describes why mock data is shown. */
  reason?: string;
  /** Present when status is 'live', ISO 8601 timestamp of the most recent real event. */
  lastEvent?: string;
}

export interface DataSourcesHealthResponse {
  dataSources: Record<string, DataSourceInfo>;
  summary: { live: number; mock: number; error: number };
  checkedAt: string;
}

// ============================================================================
// Individual probe functions
// ============================================================================

/**
 * Probe the event-bus projection.
 * Live if the projection has received at least one event.
 */
function probeEventBus(): DataSourceInfo {
  try {
    const view = projectionService.getView<EventBusPayload>('event-bus');
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const payload = snapshot.payload;
    if (!payload || payload.totalEventsIngested === 0) {
      return { status: 'mock', reason: 'no_events_ingested' };
    }
    // Use snapshotTimeMs (the time the snapshot was taken) as a proxy for lastEvent
    const lastEvent =
      snapshot.snapshotTimeMs != null ? new Date(snapshot.snapshotTimeMs).toISOString() : undefined;
    return { status: 'live', lastEvent };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the effectiveness projection.
 * Live if the summary shows at least one session.
 */
function probeEffectiveness(): DataSourceInfo {
  try {
    const view = projectionService.getView<EffectivenessMetricsPayload>('effectiveness-metrics') as
      | EffectivenessMetricsProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const summary = snapshot.payload?.summary;
    if (!summary || summary.total_sessions === 0) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the extraction-metrics projection.
 * Live if summary.last_event_at is not null (at least one row ever written).
 */
function probeExtraction(): DataSourceInfo {
  try {
    const view = projectionService.getView<ExtractionMetricsPayload>('extraction-metrics') as
      | ExtractionMetricsProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const summary = snapshot.payload?.summary;
    if (!summary || summary.last_event_at == null) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live', lastEvent: summary.last_event_at };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the baselines projection.
 * Live if at least one comparison row exists (total_comparisons > 0).
 */
function probeBaselines(): DataSourceInfo {
  try {
    const view = projectionService.getView<BaselinesPayload>('baselines') as
      | BaselinesProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const baselines = snapshot.payload;
    if (!baselines || baselines.summary.total_comparisons === 0) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the cost-metrics projection.
 * Live if session_count > 0 or total_tokens > 0.
 */
function probeCost(): DataSourceInfo {
  try {
    const view = projectionService.getView<CostMetricsPayload>('cost-metrics') as
      | CostMetricsProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const summary = snapshot.payload?.summary;
    if (!summary || (summary.session_count === 0 && summary.total_tokens === 0)) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the intent projection.
 * Live if the projection has at least one classified intent.
 */
function probeIntents(): DataSourceInfo {
  try {
    const view = projectionService.getView<IntentProjectionPayload>('intent');
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const payload = snapshot.payload;
    if (!payload || payload.totalIntents === 0) {
      return { status: 'mock', reason: 'no_intents_classified' };
    }
    const lastEvent =
      payload.lastEventTimeMs != null ? new Date(payload.lastEventTimeMs).toISOString() : undefined;
    return { status: 'live', lastEvent };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the node registry projection.
 * Live if at least one node is registered.
 */
function probeNodeRegistry(): DataSourceInfo {
  try {
    const view = projectionService.getView<NodeRegistryPayload>('node-registry');
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    const payload = snapshot.payload;
    if (!payload || payload.stats.totalNodes === 0) {
      return { status: 'mock', reason: 'no_nodes_registered' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the validation projection.
 * Live if at least one validation run exists (totalRuns > 0).
 */
function probeValidation(): DataSourceInfo {
  try {
    const view = projectionService.getView<ValidationProjectionPayload>('validation') as
      | ValidationProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    if (snapshot.payload.totalRuns === 0) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the insights data source by querying pattern_learning_artifacts (OMN-2924).
 * Live if at least one pattern artifact exists.
 *
 * The legacy learned_patterns table has been removed; canonical data source is now
 * pattern_learning_artifacts populated via the pattern-projection.v1 Kafka consumer.
 */
async function probeInsights(): Promise<DataSourceInfo> {
  try {
    const db = tryGetIntelligenceDb();
    if (!db) {
      return { status: 'mock', reason: 'no_db_connection' };
    }
    const result = await db.select({ total: count() }).from(patternLearningArtifacts);
    const total = result[0]?.total ?? 0;
    if (total === 0) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the patterns projection.
 * Live if at least one pattern artifact exists (totalPatterns > 0).
 */
function probePatterns(): DataSourceInfo {
  try {
    const view = projectionService.getView<PatternsProjectionPayload>('patterns') as
      | PatternsProjection
      | undefined;
    if (!view) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const snapshot = view.getSnapshot();
    if (!snapshot) {
      return { status: 'mock', reason: 'empty_projection' };
    }
    if (snapshot.payload.totalPatterns === 0) {
      return { status: 'mock', reason: 'empty_tables' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the execution graph data source via the EventBusDataSource directly.
 * Live if at least one execution event has been stored.
 */
async function probeExecutionGraph(): Promise<DataSourceInfo> {
  try {
    const dataSource = getEventBusDataSource();
    if (!dataSource) {
      return { status: 'mock', reason: 'no_projection_registered' };
    }
    const rawEvents = await dataSource.queryEvents({
      // Match both canonical onex.evt.omniclaude.* topics (new producers) and
      // legacy flat topic names (existing DB rows stored before OMN-2760).
      event_types: [
        // Canonical omniclaude agent topics (OMN-2760)
        TOPIC_OMNICLAUDE_AGENT_ACTIONS,
        TOPIC_OMNICLAUDE_ROUTING_DECISIONS,
        TOPIC_OMNICLAUDE_AGENT_TRANSFORMATION,
        // Legacy flat topic names (pre-OMN-2760 DB rows)
        LEGACY_AGENT_ACTIONS,
        LEGACY_AGENT_ROUTING_DECISIONS,
        LEGACY_AGENT_TRANSFORMATION_EVENTS,
        // Payload event_type field values (producer-set, not topic-derived)
        'AGENT_ACTION',
        'ROUTING_DECISION',
        'AGENT_TRANSFORMATION',
      ],
      limit: 1,
      order_by: 'timestamp',
      order_direction: 'desc',
    });
    if (!rawEvents || rawEvents.length === 0) {
      return { status: 'mock', reason: 'no_execution_data' };
    }
    return { status: 'live' };
  } catch {
    return { status: 'error', reason: 'probe_threw' };
  }
}

/**
 * Probe the enforcement data source (OMN-2374).
 * Delegates to EnforcementProjection.probeRecentCount() which encapsulates
 * the DB query following the OMN-2325 architectural rule (no direct DB access
 * from route files). Returns live status with the count of enforcement events
 * in the last hour, or error/mock when the DB is unavailable.
 */
async function probeEnforcement(): Promise<DataSourceInfo> {
  try {
    const count = await enforcementProjection.probeRecentCount();
    if (count === null) {
      return { status: 'mock', reason: 'no_db_connection' };
    }
    return { status: 'live' };
  } catch (err) {
    console.error('[health] enforcement probe failed:', err);
    return { status: 'error', reason: 'db_query_failed' };
  }
}

// ============================================================================
// Router
// ============================================================================

const router = Router();

// Module-level TTL cache (30 s). Intentionally shared across all requests in
// the same process — there is no per-request or data-change invalidation. If
// upstream data changes mid-TTL, the cached response will be stale until
// expiry. This is acceptable: data source status changes infrequently and the
// 30 s window keeps the panel responsive during demos without hammering the DB.
//
// isError: true marks a short-TTL negative cache entry written when the outer
// catch fires (all probes failed unexpectedly). The 5 s TTL prevents a
// thundering herd of re-probes during a sustained infrastructure failure.
let healthCache: {
  result: DataSourcesHealthResponse;
  expiresAt: number;
  isError?: boolean;
} | null = null;

// Pending-probe singleton: when a probe run is already in flight, subsequent
// requests that arrive before the cache is populated await this promise instead
// of starting an independent probe run (thundering-herd guard).
let pendingProbe: Promise<DataSourcesHealthResponse> | null = null;

/**
 * Clear the health cache and the pending-probe singleton.
 * Exported for use in tests to prevent state leakage between test cases that
 * run in the same process.
 */
export function clearHealthCache(): void {
  healthCache = null;
  pendingProbe = null;
}

/**
 * GET /api/health/data-sources
 *
 * Returns a snapshot of every dashboard data source reporting whether it is
 * currently using live data or falling back to mock/demo data.
 */
router.get('/data-sources', async (_req, res) => {
  try {
    // Serve cached result if still fresh.
    // Cache-Control: no-store is applied to all response branches intentionally —
    // prevents browsers and proxies from caching this health payload regardless of branch.
    if (healthCache && Date.now() < healthCache.expiresAt) {
      res.set('Cache-Control', 'no-store');
      if (healthCache.isError) {
        // Cached failure — return 503 without re-probing until the short TTL expires.
        res.status(503).json({ error: 'Service temporarily unavailable' });
        return;
      }
      res.json(healthCache.result);
      return;
    }

    // Thundering-herd guard: if a probe run is already in flight, wait for it
    // and return from cache instead of starting an independent probe suite.
    if (pendingProbe !== null) {
      const result = await pendingProbe;
      res.set('Cache-Control', 'no-store');
      res.json(result);
      return;
    }

    // No cached result and no in-flight probe — start a new probe run and
    // store the promise so concurrent requests can attach to it.
    pendingProbe = (async (): Promise<DataSourcesHealthResponse> => {
      try {
        // Run all probes. Projection-based probes are synchronous; async probes
        // (insights, executionGraph, enforcement) are awaited via Promise.all.
        // All are called directly without HTTP self-calls.
        const [insights, executionGraph, enforcement] = await Promise.all([
          probeInsights(),
          probeExecutionGraph(),
          probeEnforcement(),
        ]);
        const validation = probeValidation();
        const patterns = probePatterns();

        // Probe the event bus once and reuse the result for correlationTrace, which
        // derives its live/mock status from the same event-bus projection.
        const eventBus = probeEventBus();

        const dataSources: Record<string, DataSourceInfo> = {
          eventBus,
          effectiveness: probeEffectiveness(),
          extraction: probeExtraction(),
          baselines: probeBaselines(),
          costTrends: probeCost(),
          intents: probeIntents(),
          nodeRegistry: probeNodeRegistry(),
          correlationTrace: { ...eventBus },
          validation,
          insights,
          patterns,
          executionGraph,
          enforcement,
        };

        const counts = Object.values(dataSources).reduce(
          (acc, info) => {
            acc[info.status] = (acc[info.status] ?? 0) + 1;
            return acc;
          },
          { live: 0, mock: 0, error: 0 } as { live: number; mock: number; error: number }
        );

        const body: DataSourcesHealthResponse = {
          dataSources,
          summary: counts,
          checkedAt: new Date().toISOString(),
        };

        healthCache = { result: body, expiresAt: Date.now() + 30_000 };
        return body;
      } finally {
        // Always clear the pending-probe singleton so the next request after
        // TTL expiry can start a fresh probe run (even if this run threw).
        pendingProbe = null;
      }
    })();

    const body = await pendingProbe;
    res.set('Cache-Control', 'no-store');
    res.json(body);
  } catch {
    // Short negative cache to prevent a thundering herd of re-probes on
    // sustained failure. 5 s TTL vs the normal 30 s for successful results.
    //
    // Note: pendingProbe is already null here (cleared in the IIFE's finally)
    // — a concurrent request arriving in this narrow window starts a fresh
    // probe run rather than attaching to the error cache; this is acceptable
    // as the window is sub-millisecond.
    healthCache = {
      result: {} as DataSourcesHealthResponse,
      expiresAt: Date.now() + 5_000,
      isError: true,
    };
    res.set('Cache-Control', 'no-store');
    res.status(503).json({ error: 'Service temporarily unavailable' });
  }
});

export default router;
